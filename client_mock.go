// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package client

import (
	"context"
	"github.com/dopl-technologies/api-protos-go"
	"sync"
)

var (
	lockInterfaceMockClose       sync.RWMutex
	lockInterfaceMockCreate      sync.RWMutex
	lockInterfaceMockDelete      sync.RWMutex
	lockInterfaceMockGet         sync.RWMutex
	lockInterfaceMockJoin        sync.RWMutex
	lockInterfaceMockList        sync.RWMutex
	lockInterfaceMockListWaiting sync.RWMutex
	lockInterfaceMockWaitFor     sync.RWMutex
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
//     func TestSomethingThatUsesInterface(t *testing.T) {
//
//         // make and configure a mocked Interface
//         mockedInterface := &InterfaceMock{
//             CloseFunc: func()  {
// 	               panic("mock out the Close method")
//             },
//             CreateFunc: func(name string, deviceIDs []uint64) (*dtprotos.Session, error) {
// 	               panic("mock out the Create method")
//             },
//             DeleteFunc: func(id uint64) error {
// 	               panic("mock out the Delete method")
//             },
//             GetFunc: func(id uint64) (*dtprotos.Session, error) {
// 	               panic("mock out the Get method")
//             },
//             JoinFunc: func(deviceID uint64, sessionID uint64) (<-chan *dtprotos.SessionDevice, context.CancelFunc, error) {
// 	               panic("mock out the Join method")
//             },
//             ListFunc: func() ([]*dtprotos.Session, error) {
// 	               panic("mock out the List method")
//             },
//             ListWaitingFunc: func() ([]*dtprotos.Device, error) {
// 	               panic("mock out the ListWaiting method")
//             },
//             WaitForFunc: func(deviceID uint64) (<-chan *dtprotos.WaitForSessionResponse, context.CancelFunc, error) {
// 	               panic("mock out the WaitFor method")
//             },
//         }
//
//         // use mockedInterface in code that requires Interface
//         // and then make assertions.
//
//     }
type InterfaceMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func()

	// CreateFunc mocks the Create method.
	CreateFunc func(name string, deviceIDs []uint64) (*dtprotos.Session, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(id uint64) error

	// GetFunc mocks the Get method.
	GetFunc func(id uint64) (*dtprotos.Session, error)

	// JoinFunc mocks the Join method.
	JoinFunc func(deviceID uint64, sessionID uint64) (<-chan *dtprotos.SessionDevice, context.CancelFunc, error)

	// ListFunc mocks the List method.
	ListFunc func() ([]*dtprotos.Session, error)

	// ListWaitingFunc mocks the ListWaiting method.
	ListWaitingFunc func() ([]*dtprotos.Device, error)

	// WaitForFunc mocks the WaitFor method.
	WaitForFunc func(deviceID uint64) (<-chan *dtprotos.WaitForSessionResponse, context.CancelFunc, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Name is the name argument value.
			Name string
			// DeviceIDs is the deviceIDs argument value.
			DeviceIDs []uint64
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// ID is the id argument value.
			ID uint64
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// ID is the id argument value.
			ID uint64
		}
		// Join holds details about calls to the Join method.
		Join []struct {
			// DeviceID is the deviceID argument value.
			DeviceID uint64
			// SessionID is the sessionID argument value.
			SessionID uint64
		}
		// List holds details about calls to the List method.
		List []struct {
		}
		// ListWaiting holds details about calls to the ListWaiting method.
		ListWaiting []struct {
		}
		// WaitFor holds details about calls to the WaitFor method.
		WaitFor []struct {
			// DeviceID is the deviceID argument value.
			DeviceID uint64
		}
	}
}

// Close calls CloseFunc.
func (mock *InterfaceMock) Close() {
	if mock.CloseFunc == nil {
		panic("InterfaceMock.CloseFunc: method is nil but Interface.Close was just called")
	}
	callInfo := struct {
	}{}
	lockInterfaceMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockInterfaceMockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedInterface.CloseCalls())
func (mock *InterfaceMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockInterfaceMockClose.RLock()
	calls = mock.calls.Close
	lockInterfaceMockClose.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *InterfaceMock) Create(name string, deviceIDs []uint64) (*dtprotos.Session, error) {
	if mock.CreateFunc == nil {
		panic("InterfaceMock.CreateFunc: method is nil but Interface.Create was just called")
	}
	callInfo := struct {
		Name      string
		DeviceIDs []uint64
	}{
		Name:      name,
		DeviceIDs: deviceIDs,
	}
	lockInterfaceMockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	lockInterfaceMockCreate.Unlock()
	return mock.CreateFunc(name, deviceIDs)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//     len(mockedInterface.CreateCalls())
func (mock *InterfaceMock) CreateCalls() []struct {
	Name      string
	DeviceIDs []uint64
} {
	var calls []struct {
		Name      string
		DeviceIDs []uint64
	}
	lockInterfaceMockCreate.RLock()
	calls = mock.calls.Create
	lockInterfaceMockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *InterfaceMock) Delete(id uint64) error {
	if mock.DeleteFunc == nil {
		panic("InterfaceMock.DeleteFunc: method is nil but Interface.Delete was just called")
	}
	callInfo := struct {
		ID uint64
	}{
		ID: id,
	}
	lockInterfaceMockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockInterfaceMockDelete.Unlock()
	return mock.DeleteFunc(id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedInterface.DeleteCalls())
func (mock *InterfaceMock) DeleteCalls() []struct {
	ID uint64
} {
	var calls []struct {
		ID uint64
	}
	lockInterfaceMockDelete.RLock()
	calls = mock.calls.Delete
	lockInterfaceMockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *InterfaceMock) Get(id uint64) (*dtprotos.Session, error) {
	if mock.GetFunc == nil {
		panic("InterfaceMock.GetFunc: method is nil but Interface.Get was just called")
	}
	callInfo := struct {
		ID uint64
	}{
		ID: id,
	}
	lockInterfaceMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockInterfaceMockGet.Unlock()
	return mock.GetFunc(id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedInterface.GetCalls())
func (mock *InterfaceMock) GetCalls() []struct {
	ID uint64
} {
	var calls []struct {
		ID uint64
	}
	lockInterfaceMockGet.RLock()
	calls = mock.calls.Get
	lockInterfaceMockGet.RUnlock()
	return calls
}

// Join calls JoinFunc.
func (mock *InterfaceMock) Join(deviceID uint64, sessionID uint64) (<-chan *dtprotos.SessionDevice, context.CancelFunc, error) {
	if mock.JoinFunc == nil {
		panic("InterfaceMock.JoinFunc: method is nil but Interface.Join was just called")
	}
	callInfo := struct {
		DeviceID  uint64
		SessionID uint64
	}{
		DeviceID:  deviceID,
		SessionID: sessionID,
	}
	lockInterfaceMockJoin.Lock()
	mock.calls.Join = append(mock.calls.Join, callInfo)
	lockInterfaceMockJoin.Unlock()
	return mock.JoinFunc(deviceID, sessionID)
}

// JoinCalls gets all the calls that were made to Join.
// Check the length with:
//     len(mockedInterface.JoinCalls())
func (mock *InterfaceMock) JoinCalls() []struct {
	DeviceID  uint64
	SessionID uint64
} {
	var calls []struct {
		DeviceID  uint64
		SessionID uint64
	}
	lockInterfaceMockJoin.RLock()
	calls = mock.calls.Join
	lockInterfaceMockJoin.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *InterfaceMock) List() ([]*dtprotos.Session, error) {
	if mock.ListFunc == nil {
		panic("InterfaceMock.ListFunc: method is nil but Interface.List was just called")
	}
	callInfo := struct {
	}{}
	lockInterfaceMockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	lockInterfaceMockList.Unlock()
	return mock.ListFunc()
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//     len(mockedInterface.ListCalls())
func (mock *InterfaceMock) ListCalls() []struct {
} {
	var calls []struct {
	}
	lockInterfaceMockList.RLock()
	calls = mock.calls.List
	lockInterfaceMockList.RUnlock()
	return calls
}

// ListWaiting calls ListWaitingFunc.
func (mock *InterfaceMock) ListWaiting() ([]*dtprotos.Device, error) {
	if mock.ListWaitingFunc == nil {
		panic("InterfaceMock.ListWaitingFunc: method is nil but Interface.ListWaiting was just called")
	}
	callInfo := struct {
	}{}
	lockInterfaceMockListWaiting.Lock()
	mock.calls.ListWaiting = append(mock.calls.ListWaiting, callInfo)
	lockInterfaceMockListWaiting.Unlock()
	return mock.ListWaitingFunc()
}

// ListWaitingCalls gets all the calls that were made to ListWaiting.
// Check the length with:
//     len(mockedInterface.ListWaitingCalls())
func (mock *InterfaceMock) ListWaitingCalls() []struct {
} {
	var calls []struct {
	}
	lockInterfaceMockListWaiting.RLock()
	calls = mock.calls.ListWaiting
	lockInterfaceMockListWaiting.RUnlock()
	return calls
}

// WaitFor calls WaitForFunc.
func (mock *InterfaceMock) WaitFor(deviceID uint64) (<-chan *dtprotos.WaitForSessionResponse, context.CancelFunc, error) {
	if mock.WaitForFunc == nil {
		panic("InterfaceMock.WaitForFunc: method is nil but Interface.WaitFor was just called")
	}
	callInfo := struct {
		DeviceID uint64
	}{
		DeviceID: deviceID,
	}
	lockInterfaceMockWaitFor.Lock()
	mock.calls.WaitFor = append(mock.calls.WaitFor, callInfo)
	lockInterfaceMockWaitFor.Unlock()
	return mock.WaitForFunc(deviceID)
}

// WaitForCalls gets all the calls that were made to WaitFor.
// Check the length with:
//     len(mockedInterface.WaitForCalls())
func (mock *InterfaceMock) WaitForCalls() []struct {
	DeviceID uint64
} {
	var calls []struct {
		DeviceID uint64
	}
	lockInterfaceMockWaitFor.RLock()
	calls = mock.calls.WaitFor
	lockInterfaceMockWaitFor.RUnlock()
	return calls
}
